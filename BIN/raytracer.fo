extern i8* fopen(i8* filename, i8* mode);
extern i32 fclose(i8* ptr);

extern void c_fwrite_str(i8* ptr, i8* str);
extern void c_fwrite_i32(i8* ptr, i32 x);
extern void c_fwrite_space(i8* ptr);
extern void c_fwrite_newline(i8* ptr);

extern f32 sqrtf(f32 x);
extern f32 fabsf(f32 x);

extern f32 zero();
extern f32 one();

extern void printInt(i32 x);
extern void printPtr(i8* x);
extern i32 puts(i8* str);
extern void c_check_stack();

extern i8* malloc(i32 size);
extern void free(i8* ptr);



i32 img_width = 1000;
i32 img_height = 1000;

i32 img_depth = 5;

struct texture texture_pure(f32 x, f32 y, f32 z) {
    return new texture { primary: new v3f { x: x, y: y, z: z }, secondary: vzero(), checkered: false, checker_size: 0 };
}

struct texture red_texture = texture_pure(1, ((f32)8) / 10, ((f32)8) / 10);
struct texture green_texture = texture_pure(((f32)8) / 10, 1, ((f32)8) / 10);
struct texture blue_texture = texture_pure(((f32)8) / 10, ((f32)8) / 10, 1);
struct texture white_texture = texture_pure(1, 1, 1);

struct texture checkerboard_texture = new texture { primary: new v3f { x: 1, y: 1, z: 1 }, secondary: new v3f { x: ((f32)5)/10, y: ((f32)5)/10, z: ((f32)5)/10 }, checkered: true, checker_size: 1 };

struct material sphere1_material = new material { reflect: ((f32) 8) / 10, texture: red_texture };
struct material sphere2_material = new material { reflect: ((f32) 8) / 10, texture: green_texture };
struct material sphere3_material = new material { reflect: ((f32) 8) / 10, texture: blue_texture };

struct material white_plane_material = new material { reflect: 0, texture: white_texture };
struct material red_plane_material = new material { reflect: 0, texture: red_texture };
struct material green_plane_material = new material { reflect: 0, texture: green_texture };
struct material blue_plane_material = new material { reflect: 0, texture: blue_texture };
struct material checker_plane_material = new material { reflect: ((f32)1)/4, texture: checkerboard_texture };


struct sphere obj_s1 = new sphere { p: new v3f { x: 3, y: 2, z: 5 }, r: 2, material: sphere1_material };
struct sphere obj_s2 = new sphere { p: new v3f { x: -3, y: 2, z: 5 }, r: 2, material: sphere2_material };
//struct sphere obj_s3 = new sphere { p: new v3f { x: 0, y: 4, z: 4 }, r: 1, material: sphere3_material };
struct sphere obj_s3 = new sphere { p: new v3f { x: 0, y: 2, z: 7 }, r: 2, material: sphere3_material };
struct plane  obj_p1 = new plane { p: new v3f { x: 0, y: 0, z: 0 }, n: new v3f { x: 0, y: 1, z: 0 }, material: checker_plane_material};
//struct plane  obj_p2 = new plane { p: new v3f { x: 0, y: 0, z: 10 }, n: new v3f { x: 0, y: 0, z: -1 }, material: white_plane_material };
//struct plane  obj_p3 = new plane { p: new v3f { x: -10, y: 0, z: 0 }, n: new v3f { x: 1, y: 0, z: 0 }, material: red_plane_material };
//struct plane  obj_p4 = new plane { p: new v3f { x: 10, y: 0, z: 0 }, n: new v3f { x: -1, y: 0, z: 0 }, material: green_plane_material };




struct v3f {
    f32 x;
    f32 y;
    f32 z;
}
struct v3f vzero() {
    return new v3f { x: zero(), y: zero(), z: zero() };
}
struct v3f vadd(struct v3f a, struct v3f b) {
    return new v3f { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };
}
struct v3f vsub(struct v3f a, struct v3f b) {
    return new v3f { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
}
struct v3f vcopy(struct v3f a) {
    return new v3f { x: a.x, y: a.y, z: a.z };
}
f32 vmag(struct v3f a) {
    return sqrtf(a.x * a.x + a.y * a.y + a.z * a.z);
}
struct v3f vmul(f32 a, struct v3f b) {
    return new v3f { x: a * b.x, y: a * b.y, z: a * b.z };
}
struct v3f vnorm(struct v3f a) {
    f32 m = vmag(a);
    return vmul(one() / m, a);
}
f32 vdot(struct v3f a, struct v3f b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}




struct material {
    f32 reflect;
    struct texture texture;
}

struct texture {
    struct v3f primary;
    struct v3f secondary;
    bool checkered;
    f32 checker_size;
}

struct texture texture_checkered(struct v3f primary, struct v3f secondary, f32 checker_size) {
    return new texture { primary: primary, secondary: secondary, checkered: true, checker_size: checker_size };
}

struct v3f texture_eval(struct texture texture, struct ray_hit ray_hit) {
    if texture.checkered {
        i32 x = (i32) (ray_hit.hit_pos.x / texture.checker_size);
        i32 z = (i32) (ray_hit.hit_pos.z / texture.checker_size);
        return if (x + z) % 2 == 0 { texture.primary } else { texture.secondary };
    } else {
        return texture.primary;
    }
}

struct ray {
    struct v3f x0;
    struct v3f d; /* norm */
}

struct sphere {
    struct v3f p;
    f32 r;
    struct material material;
}

struct plane {
    struct v3f p;
    struct v3f n;
    struct material material;
}

struct ray_hit {
    bool success;
    f32 dist;
    struct v3f incoming_ray;
    struct v3f hit_pos;
    struct v3f normal;
    struct material material;
}

/* t0 <= t1 */
bool try_quadratic_solve(f32 a, f32 b, f32 c, f32* t0, f32* t1) {
    f32 discr = b * b - ((f32)4) * a * c;
    if discr < 0 { return false; }
    discr = sqrtf(discr);
    t0[0] = (-b - discr) / (((f32)2) * a);
    t1[0] = (-b + discr) / (((f32)2) * a);
    return true;
}

void try_sphere_ray_hit(struct sphere sphere, struct ray ray) {
    struct v3f p = sphere.p;
    f32 r = sphere.r;
    struct v3f x0 = ray.x0;
    struct v3f d = ray.d;

//    struct v3f L = vsub(p, x0);
//    f32 tca = vdot(L, d);
//    f32 d2 = vdot(L, L) - tca * tca;
//    if d2 > r * r { return; }
//    f32 thc = sqrtf(r * r - d2);
//    f32 t0 = tca - thc;
//    f32 t1 = tca + thc;
//
//    if t0 > t1 {
//        f32 temp = t0;
//        t0 = t1;
//        t1 = temp;
//    }
//
//    if t0 < 0 {
//        t0 = t1;
//        if t0 < 0 { return; }
//    }
//    f32 t = t0;

    struct v3f L = vsub(x0, p);

    f32 a = vdot(d, d);
    f32 b = vdot(d, L) * 2;
    f32 c = vdot(L, L) - r * r;

    f32 t0 = (f32) 0;
    f32 t1 = (f32) 0;

    if !try_quadratic_solve(a, b, c, &t0, &t1) { return; }

    f32 t = (f32) 0;

    if t0 < 0 && t1 < 0 { return; }
    if t0 < 0 && t1 >= 0 { t = t1; }
    if t0 >= 0 && t1 < 0 { t = t0; }
    if t0 >= 0 && t1 >= 0 { t = if t0 < t1 { t0 } else { t1 }; }

//    ray_hit->success = true;
//    ray_hit->dist = t0;
    struct v3f hit_pos = vadd(x0, vmul(t0, d));
//    ray_hit->normal = vnorm(vsub(ray_hit->hit_pos, p));
//    ray_hit->material = sphere.material;
    final_hit = ray_hit_closest(final_hit, new ray_hit {
        success: true,
        dist: t0,
        incoming_ray: d,
        hit_pos: hit_pos,
        normal: vnorm(vsub(hit_pos, p)),
        material: sphere.material
    });
}
void try_plane_ray_hit(struct plane plane, struct ray ray) {
    struct v3f p = plane.p;
    struct v3f n = plane.n;
    struct v3f x0 = ray.x0;
    struct v3f d = ray.d;

    f32 div = vdot(d, n);
    if fabsf(div) < ((f32)1) / 1000 { return; }

    f32 t = vdot(vsub(p, x0), n) / div;
    if t < 0 { return; }

    final_hit = ray_hit_closest(final_hit, new ray_hit {
        success: true,
        dist: t,
        incoming_ray: d,
        hit_pos: vadd(x0, vmul(t, d)),
        normal: n,
        material: plane.material
    });
}

f32 flerp(f32 a, f32 b, f32 t) { return a + (b - a) * t; }
f32 fnorm(f32 x, f32 a, f32 b) { return (x - a) / (b - a); }
f32 fmap(f32 x, f32 a1, f32 b1, f32 a2, f32 b2) {
    if PRINT_DEBUG { puts("inside fmap"); }
    f32 norm = fnorm(x, a1, b1);
    if PRINT_DEBUG { puts("after norm"); }
    return flerp(a2, b2, norm);
}
struct v3f vmap(struct v3f x, f32 a1, f32 b1, f32 a2, f32 b2) {
    return new v3f {
        x: fmap(x.x, a1, b1, a2, b2),
        y: fmap(x.y, a1, b1, a2, b2),
        z: fmap(x.z, a1, b1, a2, b2)
    };
}

struct ray_hit ray_hit_closest(struct ray_hit a, struct ray_hit b) {
    if !a.success { return b; }
    if !b.success { return a; }
    if a.dist < b.dist { return a; }
    else { return b; }
}

struct ray_hit final_hit = zeroinit(struct ray_hit);

struct ray_hit cast_ray(struct ray ray) {
    final_hit = zeroinit(struct ray_hit);

    try_sphere_ray_hit(obj_s1, ray);
    try_sphere_ray_hit(obj_s2, ray);
    try_sphere_ray_hit(obj_s3, ray);
    try_plane_ray_hit(obj_p1, ray);
//    try_plane_ray_hit(obj_p2, ray, &rh_p2);
//    try_plane_ray_hit(obj_p3, ray, &rh_p3);
//    try_plane_ray_hit(obj_p4, ray, &rh_p4);

    final_hit.incoming_ray = ray.d;
//    if final_hit.hit_pos.z < 3 {
//        final_hit.success = false;
//    }
//    final_hit.hit_pos = vadd(ray.x0, vmul(final_hit.dist, ray.d));

    return final_hit;
}

struct v3f vreflect(struct v3f I, struct v3f N) {
    return vsub(
        I,
        vmul(
            ((f32)2) * vdot(N, I),
            N
        )
    );
}

struct v3f eval_ray_hit(struct ray_hit ray_hit, i32 depth) {
    if PRINT_DEBUG {
        puts("eval_ray_hit");
        printInt(depth);
        c_check_stack();
    }
    if !ray_hit.success { return new v3f { x: 1, y: 1, z: 1}; }
    struct v3f base_color = texture_eval(ray_hit.material.texture, ray_hit);
    if depth <= 1 {
        return base_color;
    }

    struct v3f outgoing_ray = vreflect(ray_hit.incoming_ray, ray_hit.normal);

    if PRINT_DEBUG { puts("outgoing_ray"); }

    f32 epsilon = ((f32)1)/1000;

    struct v3f ray_start_pos = vadd(ray_hit.hit_pos, vmul(epsilon, ray_hit.normal));
    ray_start_pos = vnorm(ray_start_pos);

    struct ray ray = new ray { x0: ray_start_pos, d: outgoing_ray };
    struct ray_hit next_hit = cast_ray(ray);

    if PRINT_DEBUG { puts("next_hit"); }
    if PRINT_DEBUG { puts("RECURSING EVAL_RAY_HIT"); printInt(depth); printInt(depth - 1); }
    struct v3f reflect_color = eval_ray_hit(next_hit, depth - 1);

    /* reflect = 0 => no reflection component, reflect = 1 => full reflection */
    reflect_color = vmap(reflect_color, 0, 1, ((f32)1) - ray_hit.material.reflect, 1);
    struct v3f color = new v3f {
        x: base_color.x * reflect_color.x,
        y: base_color.y * reflect_color.y,
        z: base_color.z * reflect_color.z
    };

    struct v3f dl = new v3f { x: ((f32)0)/10, y: ((f32)-5)/10, z: ((f32)-3)/10 };
    dl = vnorm(dl);
    f32 m = vdot(dl, ray_hit.normal);
    m = fmap(m, -1, 1, ((f32)5)/10, 1);

    color = vmul(m, color);
    return color;
}

struct v3f get_color(f32 x, f32 y) {
    f32 range = ((f32) 8) / 10;
    f32 fx = fmap(x, 0, img_width, -range, range);
    f32 fy = fmap(y, 0, img_height, range, -range);

    struct v3f x0 = new v3f { x: 0, y: 1, z: 0 };
    struct v3f d = new v3f { x: fx, y: fy, z: 1 };
    d = vnorm(d);
//    return vmap(d, -1, 1, 0, 1);

    struct ray ray = new ray { x0: x0, d: d };

//    struct v3f color = new v3f { x: 1, y: 1, z: 1 };

//    for(i32 i = 0; i < img_depth; i = i + 1;) {
//        struct ray_hit ray_hit = cast_ray(ray);
//        color = texture_eval(ray_hit.material.texture, ray_hit);
//    }
//    return color;
//
    struct ray r = new ray { x0: x0, d: d };
    struct ray_hit h = cast_ray(r);
    return eval_ray_hit(h, img_depth);
}

bool PRINT_DEBUG = false;

struct v3f get_aa_color(f32 x, f32 y) {
//    return new v3f { x: 1, y: 1, z: 1 };
    i32 sample_grid_size = 2;
    struct v3f sum = vzero();
    f32 count = (f32) 0;
    f32 half = ((f32)1) / 2;
    for(i32 i = 0; i < sample_grid_size; i = i + 1;) {
        for(i32 j = 0; j < sample_grid_size; j = j + 1;) {
            f32 ox = fmap(i, 0, sample_grid_size - 1, -half, half);
            f32 oy = fmap(j, 0, sample_grid_size - 1, -half, half);
            sum = vadd(sum, get_color(x + ox, y + oy));
            count = count + 1;
        }
    }

    return vmul(((f32)1) / count, sum);
}

i32 get_color_r(struct v3f a) { return (i32) (a.x * 256); }
i32 get_color_g(struct v3f a) { return (i32) (a.y * 256); }
i32 get_color_b(struct v3f a) { return (i32) (a.z * 256); }


struct fo_file {
    i8* ptr;
}
struct fo_file fo_file_open(i8* filename) {
    return new fo_file { ptr: fopen(filename, "w") };
}
void fo_file_close(struct fo_file file) {
    fclose(file.ptr);
}
void fo_file_append_str(struct fo_file file, i8* str) {
    c_fwrite_str(file.ptr, str);
}
void fo_file_append_i32(struct fo_file file, i32 x) {
    c_fwrite_i32(file.ptr, x);
}


i32 run(i32 argc, i8** argv) {
    c_check_stack();

    i32* r_array = (i32*) malloc(sizeof(i32) * img_width * img_height);
    i32* g_array = (i32*) malloc(sizeof(i32) * img_width * img_height);
    i32* b_array = (i32*) malloc(sizeof(i32) * img_width * img_height);

    i32 i = 0;
    for(i32 y = 0; y < img_height; y = y + 1;) {
        for(i32 x = 0; x < img_width; x = x + 1;) {
            struct v3f col = get_aa_color(x, y);
//            i8 ix = (i8) (x / 2);
//            i8 iy = (i8) (y / 2);
//            make_i8(ix);
//            make_i8(iy);
//            i8 r = ix ^ iy;
//            i8 g = (~ix) & iy;
//            i8 b = ix | (~iy);
//            r_array[i] = r;
//            g_array[i] = g;
//            b_array[i] = b;
            r_array[i] = get_color_r(col);
            g_array[i] = get_color_g(col);
            b_array[i] = get_color_b(col);
            i = i + 1;
        }
        if y % 50 == 0 { printInt(y); }
    }


    struct fo_file file = fo_file_open("output.ppm");
    fo_file_append_str(file, "P3\n");
    fo_file_append_i32(file, img_width);
    fo_file_append_str(file, " ");
    fo_file_append_i32(file, img_height);
    fo_file_append_str(file, "\n");
    fo_file_append_str(file, "256\n");
    i = 0;
    puts("\nFile");
    for(i32 y = 0; y < img_height; y = y + 1;) {
        for(i32 x = 0; x < img_width; x = x + 1;) {
            fo_file_append_i32(file, r_array[i]);
            fo_file_append_str(file, " ");
            fo_file_append_i32(file, g_array[i]);
            fo_file_append_str(file, " ");
            fo_file_append_i32(file, b_array[i]);
            fo_file_append_str(file, "\n");
            i = i + 1;
        }
        if y % 50 == 0 { printInt(y); }
    }
    fo_file_close(file);

    free((i8*) r_array);
    free((i8*) g_array);
    free((i8*) b_array);
    return 0;
}

