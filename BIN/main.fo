i32 GL_CURRENT_BIT = 0x00000001;
i32 GL_POINT_BIT = 0x00000002;
i32 GL_LINE_BIT = 0x00000004;
i32 GL_POLYGON_BIT = 0x00000008;
i32 GL_POLYGON_STIPPLE_BIT = 0x00000010;
i32 GL_PIXEL_MODE_BIT = 0x00000020;
i32 GL_LIGHTING_BIT = 0x00000040;
i32 GL_FOG_BIT = 0x00000080;
i32 GL_DEPTH_BUFFER_BIT = 0x00000100;
i32 GL_ACCUM_BUFFER_BIT = 0x00000200;
i32 GL_STENCIL_BUFFER_BIT = 0x00000400;
i32 GL_VIEWPORT_BIT = 0x00000800;
i32 GL_TRANSFORM_BIT = 0x00001000;
i32 GL_ENABLE_BIT = 0x00002000;
i32 GL_COLOR_BUFFER_BIT = 0x00004000;
i32 GL_HINT_BIT = 0x00008000;
i32 GL_EVAL_BIT = 0x00010000;
i32 GL_LIST_BIT = 0x00020000;
i32 GL_TEXTURE_BIT = 0x00040000;
i32 GL_SCISSOR_BIT = 0x00080000;
i32 GL_MULTISAMPLE_BIT = 0x20000000;
i32 GL_MULTISAMPLE_BIT_ARB = 0x20000000;
i32 GL_MULTISAMPLE_BIT_EXT = 0x20000000;
i32 GL_MULTISAMPLE_BIT_3DFX = 0x20000000;
i32 GL_ALL_ATTRIB_BITS = 0xFFFFFFFF;
i32 GL_FALSE = 0;
i32 GL_TRUE = 1;
i32 GL_POINTS = 0x0000;
i32 GL_LINES = 0x0001;
i32 GL_LINE_LOOP = 0x0002;
i32 GL_LINE_STRIP = 0x0003;
i32 GL_TRIANGLES = 0x0004;
i32 GL_TRIANGLE_STRIP = 0x0005;
i32 GL_TRIANGLE_FAN = 0x0006;
i32 GL_QUADS = 0x0007;
i32 GL_QUADS_EXT = 0x0007;
i32 GL_QUAD_STRIP = 0x0008;
i32 GL_POLYGON = 0x0009;
i32 GL_LINES_ADJACENCY = 0x000A;
i32 GL_LINES_ADJACENCY_ARB = 0x000A;
i32 GL_LINES_ADJACENCY_EXT = 0x000A;
i32 GL_LINE_STRIP_ADJACENCY = 0x000B;
i32 GL_LINE_STRIP_ADJACENCY_ARB = 0x000B;
i32 GL_LINE_STRIP_ADJACENCY_EXT = 0x000B;
i32 GL_TRIANGLES_ADJACENCY = 0x000C;
i32 GL_TRIANGLES_ADJACENCY_ARB = 0x000C;
i32 GL_TRIANGLES_ADJACENCY_EXT = 0x000C;
i32 GL_TRIANGLE_STRIP_ADJACENCY = 0x000D;
i32 GL_TRIANGLE_STRIP_ADJACENCY_ARB = 0x000D;
i32 GL_TRIANGLE_STRIP_ADJACENCY_EXT = 0x000D;
i32 GL_PATCHES = 0x000E;
i32 GL_PATCHES_EXT = 0x000E;
i32 GL_SHORT = 0x1402;
i32 GL_INT = 0x1404;
i32 GL_FLOAT = 0x1406;
i32 GL_DOUBLE = 0x140A;
i32 GL_COMPUTE_WORK_GROUP_SIZE = 0x8267;
i32 GL_PROGRAM_BINARY_LENGTH = 0x8741;
i32 GL_ARRAY_BUFFER = 0x8892;
i32 GL_ELEMENT_ARRAY_BUFFER = 0x8893;
i32 GL_STREAM_DRAW = 0x88E0;
i32 GL_STREAM_READ = 0x88E1;
i32 GL_STREAM_COPY = 0x88E2;
i32 GL_STATIC_DRAW = 0x88E4;
i32 GL_STATIC_READ = 0x88E5;
i32 GL_STATIC_COPY = 0x88E6;
i32 GL_DYNAMIC_DRAW = 0x88E8;
i32 GL_DYNAMIC_READ = 0x88E9;
i32 GL_DYNAMIC_COPY = 0x88EA;
i32 GL_PIXEL_PACK_BUFFER = 0x88EB;
i32 GL_PIXEL_UNPACK_BUFFER = 0x88EC;
i32 GL_GEOMETRY_VERTICES_OUT = 0x8916;
i32 GL_GEOMETRY_INPUT_TYPE = 0x8917;
i32 GL_GEOMETRY_OUTPUT_TYPE = 0x8918;
i32 GL_UNIFORM_BUFFER = 0x8A11;
i32 GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = 0x8A35;
i32 GL_ACTIVE_UNIFORM_BLOCKS = 0x8A36;
i32 GL_FRAGMENT_SHADER = 0x8B30;
i32 GL_FRAGMENT_SHADER_ARB = 0x8B30;
i32 GL_VERTEX_SHADER = 0x8B31;
i32 GL_VERTEX_SHADER_ARB = 0x8B31;
i32 GL_SHADER_TYPE = 0x8B4F;
i32 GL_DELETE_STATUS = 0x8B80;
i32 GL_COMPILE_STATUS = 0x8B81;
i32 GL_LINK_STATUS = 0x8B82;
i32 GL_VALIDATE_STATUS = 0x8B83;
i32 GL_INFO_LOG_LENGTH = 0x8B84;
i32 GL_ATTACHED_SHADERS = 0x8B85;
i32 GL_ACTIVE_UNIFORMS = 0x8B86;
i32 GL_ACTIVE_UNIFORM_MAX_LENGTH = 0x8B87;
i32 GL_SHADER_SOURCE_LENGTH = 0x8B88;
i32 GL_ACTIVE_ATTRIBUTES = 0x8B89;
i32 GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = 0x8B8A;
i32 GL_TEXTURE_BUFFER = 0x8C2A;
i32 GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = 0x8C76;
i32 GL_TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F;
i32 GL_TRANSFORM_FEEDBACK_VARYINGS = 0x8C83;
i32 GL_TRANSFORM_FEEDBACK_BUFFER = 0x8C8E;
i32 GL_GEOMETRY_SHADER = 0x8DD9;
i32 GL_TESS_EVALUATION_SHADER = 0x8E87;
i32 GL_TESS_CONTROL_SHADER = 0x8E88;
i32 GL_COPY_READ_BUFFER = 0x8F36;
i32 GL_COPY_WRITE_BUFFER = 0x8F37;
i32 GL_DRAW_INDIRECT_BUFFER = 0x8F3F;
i32 GL_SHADER_STORAGE_BUFFER = 0x90D2;
i32 GL_DISPATCH_INDIRECT_BUFFER = 0x90EE;
i32 GL_QUERY_BUFFER = 0x9192;
i32 GL_COMPUTE_SHADER = 0x91B9;
i32 GL_ATOMIC_COUNTER_BUFFER = 0x92C0;
i32 GL_ACTIVE_ATOMIC_COUNTER_BUFFERS = 0x92D9;
extern void glAttachShader(i32 program, i32 shader);
extern void glBindBuffer(i32 target, i32 buffer);
extern void glBindVertexArray(i32 array);
extern void glBufferData(i32 target, i32 size, i8** data, i32 usage);
extern void glClear(i32 mask);
extern void glClearColor(f32 red, f32 green, f32 blue, f32 alpha);
extern void glCompileShader(i32 shader);
extern i32 glCreateProgram();
extern i32 glCreateShader(i32 type);
extern void glDeleteBuffers(i32 n, i32* buffers);
extern void glDeleteProgram(i32 program);
extern void glDeleteShader(i32 shader);
extern void glDeleteVertexArrays(i32 n, i32* arrays);
extern void glDrawArrays(i32 mode, i32 first, i32 count);
extern void glEnableVertexAttribArray(i32 index);
extern void glGenBuffers(i32 n, i32* buffers);
extern void glGenVertexArrays(i32 n, i32* arrays);
extern void glGetProgramInfoLog(i32 program, i32 bufSize, i32* length, i8* infoLog);
extern void glGetProgramiv(i32 program, i32 pname, i32* params);
extern void glGetShaderInfoLog(i32 shader, i32 bufSize, i32* length, i8* infoLog);
extern void glGetShaderiv(i32 shader, i32 pname, i32* params);
extern void glLinkProgram(i32 program);
extern void glPolygonMode(i32 face, i32 mode);
extern void glShaderSource(i32 shader, i32 count, i8** string, i32* length);
extern void glUseProgram(i32 program);
extern void glVertexAttribPointer(i32 index, i32 size, i32 type, i32 normalized, i32 stride, i8** pointer);
extern void glViewport(i32 x, i32 y, i32 width, i32 height);

extern i32 glfwContextVersionMajor();
extern i32 glfwContextVersionMinor();
extern i32 glfwOpenGLForwardCompat();
extern i32 glfwOpenGLProfile();
extern i32 glfwOpenGLCoreProfile();

extern i32 loadGLAD();

extern i32 glfwInit();
extern void glfwTerminate();

extern i8* glfwCreateWindow(i32 width, i32 height, i8* title, i8* monitor, i8* share);
extern void glfwWindowHint(i32 hint, i32 value);
extern bool glfwWindowShouldClose(i8* window);
extern void glfwMakeContextCurrent(i8* window);
extern void glfwSwapBuffers(i8* window);
extern void glfwPollEvents();

extern i32 puts(i8* str);

i8* nullptr = (i8*) 0;

extern f32 zero();
extern f32 one();

extern i8* malloc(i32 size);
extern void free(i8* ptr);

i32 run() {
    puts("FO: Hi!");
    if glfwInit() == 0 {
        puts("FO: glfwInit failed\n");
        return 1;
    }
    puts("FO: glfwInit");

    glfwWindowHint(glfwContextVersionMajor(), 3);
    glfwWindowHint(glfwContextVersionMinor(), 3);
    glfwWindowHint(glfwOpenGLForwardCompat(), 1);
    glfwWindowHint(glfwOpenGLProfile(), glfwOpenGLCoreProfile());

    puts("FO: glfwHints");

    i8* window = glfwCreateWindow(720, 720, "FO: Hello World\0", nullptr, nullptr);

    puts("FO: window");

    if window == nullptr {
        puts("FO: glfwCreateWindow failed\n");
        glfwTerminate();
        return 1;
    }

    puts("FO: window success");

    glfwMakeContextCurrent(window);

    puts("FO: context");

    if loadGLAD() == 0 {
        puts("FO: Failed to initialize glad\n");
        return 1;
    }

    i8* vertexShaderSource = "#version 330 core\nlayout(location=0) in vec2 pos;layout(location=1) in vec3 col;out vec3 fcol;\nvoid main() {\n\tgl_Position = vec4(pos.x, pos.y, 0.0, 1.0);fcol=col;\n}";
    i8* fragmentShaderSource = "#version 330 core\nout vec4 fc;in vec3 fcol;\nvoid main() {\n\tfc = vec4(fcol, 1.0);\n}";

    puts(vertexShaderSource);
    puts(fragmentShaderSource);


    i32 vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexShaderSource, (i32*) nullptr);
    glCompileShader(vertexShader);
    i32 success = 0;
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
    if success == 0 {
        i8* msg = malloc(512);
        glGetShaderInfoLog(vertexShader, 512, (i32*) nullptr, msg);
        puts("FO: Vertex shader compilation error");
        puts(msg);
        free(msg);
        return 1;
    } else {
        puts("FO: Vertex shader success");
    }

    i32 fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentShaderSource, (i32*) nullptr);
    glCompileShader(fragmentShader);
    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
    if success == 0 {
        i8* msg = malloc(512);
        glGetShaderInfoLog(fragmentShader, 512, (i32*) nullptr, msg);
        puts("FO: Fragment shader compilation error");
        puts(msg);
        free(msg);
        return 1;
    } else {
        puts("FO: Fragment shader success");
    }

    i32 shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);
    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
    if success == 0 {
        i8* msg = malloc(512);
        glGetProgramInfoLog(shaderProgram, 512, (i32*) nullptr, msg);
        puts("FO: Shader program linking error");
        puts(msg);
        free(msg);
        return 1;
    } else {
        puts("FO: Shader program success");
    }

    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    puts("FO: cleaned shaders");

    f32 o = one();
    f32 zpf = o / (o + o);
    f32 z = zero();

    puts("FO: temps");

    f32* vertices = (f32*) malloc(4 * 6);

    puts("FO: \tvertices alloc");

    vertices[0] = z;
    vertices[1] = o / (o + o);

    vertices[2] = z - zpf;
    vertices[3] = z - zpf / (o + o);

    vertices[4] = zpf;
    vertices[5] = z - zpf / (o + o);

    puts("FO: vertices");

    f32* colors = (f32*) malloc(4 * 9);

    colors[0] = o;
    colors[1] = z;
    colors[2] = z;

    colors[3] = z;
    colors[4] = o;
    colors[5] = z;

    colors[6] = z;
    colors[7] = z;
    colors[8] = o;

    puts("FO: colors");

    i32 vao = 0;
    i32 vboPos = 0;
    i32 vboCol = 0;
    glGenVertexArrays(1, &vao);
    glGenBuffers(1, &vboPos);
    glGenBuffers(1, &vboCol);

    glBindVertexArray(vao);

    glBindBuffer(GL_ARRAY_BUFFER, vboPos);
    glBufferData(GL_ARRAY_BUFFER, 4 * 6, (i8**) vertices, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * 4, (i8**) nullptr);
    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    glBindBuffer(GL_ARRAY_BUFFER, vboCol);
    glBufferData(GL_ARRAY_BUFFER, 4 * 9, (i8**) colors, GL_STATIC_DRAW);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * 4, (i8**) nullptr);
    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    glBindVertexArray(0);

    free((i8*) vertices);
    free((i8*) colors);

    while !glfwWindowShouldClose(window) {
        glClearColor(zero(), zero(), zero(), one());
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        glUseProgram(shaderProgram);
        glBindVertexArray(vao);
        glDrawArrays(GL_TRIANGLES, 0, 3);
        glBindVertexArray(0);

        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glDeleteVertexArrays(1, &vao);
    glDeleteBuffers(1, &vboPos);
    glDeleteBuffers(1, &vboCol);
    glDeleteProgram(shaderProgram);

    glfwTerminate();
    return 0;
}